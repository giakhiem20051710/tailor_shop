# Cursor Rules for Tailor Shop Backend

## Project Overview
Spring Boot 3.3.3 application using Java 17, MySQL, JWT authentication, AWS S3, Flyway migrations.

## Architecture Patterns

### Modules-by-Feature Structure
- Code organized by feature modules: `auth`, `user`, `order`, `measurement`, `appointment`
- Each module contains: `domain`, `dto`, `repository`, `service`, `controller`
- Use `@Service`, `@Repository`, `@RestController` annotations
- Follow dependency injection via constructor

### Domain-Driven Design
- Entities in `domain` package (e.g., `OrderEntity`, `UserEntity`)
- Use JPA annotations: `@Entity`, `@Table`, `@ManyToOne`, `@OneToMany`
- Enums for status/type (e.g., `OrderStatus`, `AppointmentType`)
- Soft delete pattern: `isDeleted` boolean field

## Coding Standards

### Code Formatting
- **Max line length**: 120 characters (hard limit, break lines if longer)
- **Indentation**: 4 spaces (NO tabs, ever)
- **Imports**: 
  - NO wildcard imports (e.g., `import java.util.*` is forbidden)
  - Organize imports automatically (IDE should sort: static imports, java.*, jakarta.*, org.*, com.*)
  - Remove unused imports
- **Line breaks**: Break lines logically for readability:
  - Method parameters: break after comma, align parameters vertically if needed
  - Method chains: break after each method call (`.method()`)
  - Long expressions: break at operators (+, -, &&, ||)
  - String concatenation: break before `+` operator
- **Example of proper formatting**:
```java
// Good: Method with proper line breaks
public ResponseEntity<CommonResponse<Page<AppointmentResponse>>> list(
        @RequestParam(value = "tailorId", required = false) Long tailorId,
        @RequestParam(value = "customerId", required = false) Long customerId,
        @PageableDefault(size = 20, sort = "appointmentDate") Pageable pageable
) {
    // method body
}

// Good: Method chain with breaks
String result = someService
        .getData()
        .process()
        .format();

// Bad: Line too long (over 120 chars)
public ResponseEntity<CommonResponse<Page<AppointmentResponse>>> list(@RequestParam(value = "tailorId", required = false) Long tailorId, @RequestParam(value = "customerId", required = false) Long customerId) {
```

### Java Code Style & Lombok Usage
- **Lombok for DTOs**: ALWAYS use `@Data`, `@Builder`, `@NoArgsConstructor`, `@AllArgsConstructor`.
- **Lombok for Entities**:
  - Use `@Getter`, `@Setter`, `@Builder`, `@NoArgsConstructor`, `@AllArgsConstructor`.
  - ⚠️ **STRICTLY FORBIDDEN**: Do NOT use `@Data` or `@EqualsAndHashCode` on `@Entity` classes (causes severe JPA/Hibernate performance issues and infinite recursion).
  - Use `@ToString` but exclude lazy-loaded relationships: `@ToString(exclude = {"orders", "appointments"})`.
- **Dependency Injection**: Use `@RequiredArgsConstructor` for Constructor Injection in Services and Controllers (instead of writing manual constructors).
- **Logging**: Use `@Slf4j` annotation for logging.
- **Transactions**: Use `@Transactional` on service methods (public methods).
- **Security**: Use `@PreAuthorize` for RBAC.
- Always wrap controller responses with `CommonResponse<T>`
- Use `ResponseUtil.success(traceId, data)` for success responses
- Use `TraceIdUtil.getOrCreateTraceId()` for trace IDs
- Use Java 17 features (records, pattern matching where appropriate)

### Naming Conventions
- Entities: `*Entity` suffix (e.g., `OrderEntity`, `UserEntity`)
- DTOs: `*Request`, `*Response` suffix (e.g., `OrderRequest`, `OrderResponse`)
- Repositories: `*Repository` suffix (e.g., `OrderRepository`)
- Services: `*Service` interface, `*ServiceImpl` implementation
- Controllers: `*Controller` suffix
- Enums: PascalCase (e.g., `OrderStatus`, `AppointmentType`)

### Exception Handling
- Use custom exceptions: `BusinessException`, `NotFoundException`, `BadRequestException`, `UnauthorizedException`
- All exceptions handled by `GlobalExceptionHandler`
- Return `CommonResponse` with error details (message, traceId, timestamp)
- Use appropriate HTTP status codes: 400 (BadRequest), 404 (NotFound), 401 (Unauthorized), 403 (Forbidden)

### Validation
- Use Jakarta Validation: `@NotNull`, `@NotBlank`, `@Email`, `@Size`, `@Min`, `@Max`, `@Pattern`
- Use `@Valid` on controller method parameters
- Custom validation logic in service layer
- Validate business rules (e.g., status transitions, conflicts, ownership)

### Logging Standards
- Use `org.slf4j.Logger` via `LoggerFactory.getLogger(ClassName.class)`
- Log format: `[TraceId: {}] Message...` (Use `TraceIdUtil.getTraceId()`)
- Log Levels:
  - `ERROR`: For exceptions and system failures (include stack trace)
  - `WARN`: For business rule violations or handled anomalies
  - `INFO`: For significant state changes (e.g., "Order created", "Status changed")
  - `DEBUG`: For detailed payload inspection (only in dev/test profiles)
- NEVER log sensitive data (passwords, tokens, PII)

### Date & Time Handling
- Always use `java.time` API (Instant, LocalDateTime, ZonedDateTime)
- Database columns usually store UTC. Ensure backend logic handles timezone conversion explicitly if needed.
- Prefer `Instant` for `createdAt` and `updatedAt`.

## Security & Authentication

### JWT Authentication
- Use `JwtService` for token generation/validation
- Use `CustomUserDetails` and `CustomUserDetailsService`
- Use `@AuthenticationPrincipal CustomUserDetails principal` in controllers
- Extract user ID: `principal != null ? principal.getId() : null`

### Role-Based Access Control (RBAC)
- Roles: `ADMIN`, `STAFF`, `TAILOR`, `CUSTOMER`
- Use `@PreAuthorize("hasAnyRole('ADMIN','STAFF','TAILOR')")` for authorization
- Check customer ownership: `isCustomer && !entity.getCustomer().getId().equals(currentUserId)`
- Admin/Staff: full access
- Tailor: limited access (own appointments, own working slots)
- Customer: view-only access (own data)

## Database & Migrations

### Flyway Migrations
- Migration files: `V{version}__{description}.sql` in `src/main/resources/db.migration/`
- Always use Flyway for schema changes, never modify entities without migrations
- Use `CREATE TABLE IF NOT EXISTS` for safety
- Add indexes for foreign keys and frequently queried columns
- Use `is_deleted` boolean for soft delete pattern

### JPA Best Practices
- Use `FetchType.EAGER` for `role` in `UserEntity` (avoid LazyInitializationException)
- Use `FetchType.LAZY` for other relationships unless needed eagerly
- Use `@CreatedTimestamp` and `@UpdateTimestamp` for audit fields
- Use `@Column` with explicit names for database columns
- Use `OffsetDateTime` for timestamp fields (stored as TIMESTAMP in MySQL)
- Use `LocalDate` for date-only fields (stored as DATE in MySQL)
- Use `LocalTime` for time-only fields (stored as TIME in MySQL)

## API Design

### RESTful Endpoints
- Use standard HTTP methods: GET (read), POST (create), PUT (update), PATCH (partial update), DELETE (delete)
- Use plural nouns: `/api/v1/orders`, `/api/v1/appointments`
- Use path variables for IDs: `/api/v1/orders/{id}`
- Use query parameters for filtering: `?status=PENDING&customerId=1&page=0&size=20`
- Use `@PageableDefault` for pagination defaults

### Response Format
- Always return `ResponseEntity<CommonResponse<T>>`
- Success: `ResponseUtil.success(traceId, data)` with HTTP 200 (or 201 for POST)
- Error: Handled by `GlobalExceptionHandler` returning `CommonResponse` with error details
- Include traceId, timestamp, success flag, data/message

### Request Validation
- Use DTOs for request bodies (never expose entities directly)
- Validate all inputs: `@Valid @RequestBody DTO`
- Return meaningful error messages for validation failures

## Service Layer Patterns

### Transaction Management
- Use `@Transactional` on service methods (not repositories)
- Use `@Transactional(readOnly = true)` for read-only methods
- Handle business logic in service, not controller

### Error Handling
- Throw `NotFoundException` when entity not found
- Throw `BadRequestException` for validation/business rule violations
- Throw `UnauthorizedException` for authentication failures
- Always provide clear error messages

### Business Logic
- Validate state transitions (e.g., order status changes)
- Check conflicts (e.g., appointment time conflicts)
- Validate ownership (e.g., customer can only view own orders)
- Use helper methods for complex logic (e.g., `validateAppointmentTime`, `checkConflict`)

## File Upload (AWS S3)

### S3 Integration
- Use `S3StorageService` for file uploads
- Upload path pattern: `{module}/{entityId}/{filename}` (e.g., `orders/1/image.jpg`)
- File size limit: 50MB (configured in `application.yml`)
- Store metadata: `fileName`, `fileUrl`, `fileSize`, `fileType` in entities
- Handle upload errors gracefully

## Testing Considerations

### Postman Collections
- Create Postman collections for each module
- Include all CRUD operations
- Include error cases (validation, authorization, not found)
- Use environment variables: `{{base_url}}`, `{{token}}`

### Test Cases to Cover
- Happy path: create, read, update, delete
- Validation: invalid input, missing required fields
- Authorization: unauthorized access, wrong role
- Business rules: conflicts, state transitions, ownership
- Edge cases: empty lists, null values, boundary conditions

### Unit Testing (JUnit 5 & Mockito)
- Write unit tests for Service layer logic
- Use `@ExtendWith(MockitoExtension.class)`
- Mock all dependencies (Repositories, External Services)
- Verify interactions: `verify(repository, times(1)).save(any())`
- Test assertions must cover: Result data, Exception throwing, State changes
- Test file location: `src/test/java/com/example/tailor_shop/modules/{module}/service/impl/{Service}ImplTest.java`
- Use `@Mock` for dependencies, `@InjectMocks` for service under test
- Test both success and failure scenarios
- Use `ArgumentMatchers` (e.g., `any()`, `eq()`, `isNull()`) for flexible matching

## Code Organization

### Package Structure
```
com.example.tailor_shop
├── common/              # Common utilities (CommonResponse, ResponseUtil, TraceIdUtil)
├── config/              # Configuration (SecurityConfig, S3Config, exception handlers)
├── modules/             # Feature modules
│   ├── auth/
│   ├── user/
│   ├── order/
│   ├── measurement/
│   └── appointment/
└── TailorShopApplication.java
```

### Module Structure
```
module/
├── domain/              # JPA entities
├── dto/                 # Request/Response DTOs
├── repository/          # Spring Data JPA repositories
├── service/             # Service interfaces
│   └── impl/            # Service implementations
└── controller/          # REST controllers
```

## Common Patterns

### DTO Mapping
- Create `toResponse()` methods in service implementations
- Map entities to DTOs manually (avoid exposing entities)
- Include nested objects (e.g., `Party` for customer/tailor info)

### Pagination
- Use Spring Data `Pageable` for pagination
- Default: `@PageableDefault(size = 20, sort = "createdAt,desc")`
- Return `Page<T>` from repositories, map to `Page<ResponseDTO>`

### Filtering
- Use `@Query` annotations for complex queries
- Support multiple optional filters (use `IS NULL OR` pattern)
- Use indexes for performance

## Don'ts

- ❌ Don't use `@Data` on JPA Entities (use `@Getter/@Setter` instead).
- ❌ Don't use `@EqualsAndHashCode` on JPA Entities (causes infinite recursion with bidirectional relationships).
- ❌ Don't use `@Autowired` on fields (use `@RequiredArgsConstructor` for constructor injection).
- ❌ Don't write manual Getters/Setters/Constructors/Builders (let Lombok handle it).
- ❌ Don't modify entities without creating Flyway migrations
- ❌ Don't expose entities directly in API responses
- ❌ Don't put business logic in controllers
- ❌ Don't skip validation
- ❌ Don't return raw exceptions to clients
- ❌ Don't use `ddl-auto: create-drop` in production
- ❌ Don't hardcode values (use constants or configuration)

## Do's

- ✅ Always use `CommonResponse` wrapper
- ✅ Always validate inputs
- ✅ Always check authorization
- ✅ Always use transactions for write operations
- ✅ Always use Flyway for schema changes
- ✅ Always handle errors gracefully
- ✅ Always provide meaningful error messages
- ✅ Always use `@RequiredArgsConstructor` for constructor injection (Lombok)
- ✅ Always use Lombok annotations (`@Data` for DTOs, `@Getter/@Setter` for Entities)
- ✅ Always use `@Slf4j` for logging
- ✅ Always check entity existence before operations
- ✅ Always use soft delete pattern (`isDeleted`)
- ✅ **ALWAYS explain errors before fixing them** (analyze → propose solutions → implement)

## When Adding New Features

1. **Design First**: Update `BACKEND_DESIGN_PROCESS.md` with API contract, domain model, security rules
2. **Create Migration**: Add Flyway migration file for schema changes
3. **Create Domain**: Add entities with proper JPA annotations
4. **Create DTOs**: Add Request/Response DTOs with validation
5. **Create Repository**: Add repository with custom queries if needed
6. **Create Service**: Add service interface and implementation with business logic
7. **Create Controller**: Add REST controller with proper security and response wrapping
8. **Test**: Create Postman collection and test all scenarios
9. **Document**: Add explanation file (e.g., `MODULE_NAME_MODULE_EXPLAINED.md`)

## When Fixing Bugs or Errors

**ALWAYS explain the error first, then code the fix.**

### Step 1: Analyze the Error
- **What is the error?** Read the stack trace/log carefully
- **Where does it occur?** Identify the specific file, method, line
- **Why does it happen?** Root cause analysis (code issue, configuration, dependency, etc.)
- **Who is affected?** Which endpoints, users, or features are impacted

### Step 2: Propose Solutions
- **Solution 1**: Describe approach, pros/cons
- **Solution 2**: Alternative approach if applicable
- **Recommended Solution**: Which one to use and why

### Step 3: Implement the Fix
- **File X**: What changes and why
- **File Y**: What changes and why
- **Testing**: How to verify the fix works

### Example Error Analysis Format:
```
## Error Analysis

**Error**: [Error message from stack trace]

**Location**: [File:Line or Method]

**Root Cause**: 
- [Explanation of why this error occurs]

**Impact**:
- [What functionality is broken]
- [Who is affected]

**Solutions**:
1. **Solution A**: [Description]
   - Pros: [...]
   - Cons: [...]
2. **Solution B**: [Description]
   - Pros: [...]
   - Cons: [...]

**Recommended**: Solution A because [reason]

## Implementation
[Then proceed with code changes]
```

## Code Review Checklist

- [ ] Uses `CommonResponse` wrapper
- [ ] Proper validation annotations
- [ ] Proper authorization checks
- [ ] Transaction management
- [ ] Error handling
- [ ] No hardcoded values
- [ ] Follows naming conventions
- [ ] Proper JPA relationships
- [ ] Indexes for foreign keys
- [ ] Soft delete pattern
- [ ] No business logic in controller
- [ ] Meaningful error messages
- [ ] Proper logging with traceId
- [ ] Correct date/time handling (java.time API)
- [ ] Unit tests written for service layer
- [ ] Errors explained before fixes (if applicable)
- [ ] Code formatting: max 120 chars per line, 4 spaces indentation
- [ ] No wildcard imports, imports organized
- [ ] Lines broken logically for readability

## CI/CD Standard

### Branching Strategy
- **Primary Strategy**: GitHub Flow (trunk-based with feature branches)
  - `main`: Production-ready code (protected branch)
  - `develop`: Integration branch for features (optional, can use main directly)
  - `feature/*`: Feature branches (e.g., `feature/billing-module`, `feature/user-auth`)
  - `hotfix/*`: Critical production fixes
  - `release/*`: Release preparation branches
- **Alternative**: GitFlow for complex release cycles (if needed)
- Branch naming: `{type}/{short-description}` (lowercase, hyphens)

### Pull Request Rules
- **Required Reviews**: Minimum 1 approval from senior/lead developer
- **PR Title**: Clear, descriptive (e.g., "feat: Add billing module with invoice management")
- **PR Description**: Must include:
  - What: Summary of changes
  - Why: Business reason/requirement
  - How: Technical approach (if complex)
  - Testing: How it was tested
  - Breaking Changes: If any, clearly documented
- **PR Checklist**:
  - [ ] Code follows `.cursorrules` standards
  - [ ] Unit tests added/updated (coverage ≥ 70%)
  - [ ] Integration tests pass
  - [ ] Documentation updated (if needed)
  - [ ] No linter errors
  - [ ] Migration files included (if schema changes)
- **Merge Strategy**: Squash and merge (clean history) or Rebase and merge
- **Auto-close Issues**: Use keywords: `fixes #123`, `closes #456` in PR description

### Build Pipeline
- **Trigger**: On every push to `feature/*`, `develop`, `main`
- **Stages**:
  1. **Checkout**: Clone repository
  2. **Lint**: Code quality checks (Checkstyle, PMD, SpotBugs)
  3. **Unit Tests**: `mvn test` (must pass, coverage report)
  4. **Integration Tests**: `mvn verify` (if applicable)
  5. **Build**: `mvn clean package -DskipTests` (tests already run)
  6. **SonarQube**: Code analysis and quality gates
  7. **Docker Build**: Build Docker image (tag with commit SHA)
  8. **Security Scan**: Dependency vulnerability scan (OWASP, Snyk)
- **Artifacts**: JAR file, Docker image, test reports, coverage reports
- **Failure Handling**: Block merge if any stage fails
- **Cache Strategy**: Cache Maven dependencies (`~/.m2/repository`)

### Deployment Pipeline
- **Environments**: `dev` → `staging` → `production`
- **Deployment Strategy**:
  - **Blue-Green Deployment**: Zero-downtime deployments
    - Deploy new version to "green" environment
    - Run health checks and smoke tests
    - Switch traffic from "blue" to "green"
    - Keep "blue" running for quick rollback
  - **Canary Deployment**: For high-risk changes (gradual rollout: 10% → 50% → 100%)
- **Automated Steps**:
  1. **Pre-deployment**:
     - Run database migrations (Flyway) automatically
     - Backup database (production only)
     - Validate configuration
  2. **Deployment**:
     - Deploy to target environment
     - Health check endpoint: `/actuator/health`
     - Smoke tests (critical endpoints)
  3. **Post-deployment**:
     - S3 CloudFront cache invalidation (if static assets changed)
     - Monitor error rates and response times
     - Rollback trigger if metrics exceed thresholds
- **Rollback Strategy**:
  - Automatic rollback if health check fails within 5 minutes
  - Manual rollback via CI/CD pipeline (one-click)
  - Database migration rollback: Use Flyway `undo` scripts (if configured)
- **Migration Safety**:
  - Flyway migrations run automatically before deployment
  - Backward-compatible migrations only (no breaking changes in production)
  - Test migrations in staging first
  - Use `baselineOnMigrate` for existing databases

## Caching Layer

### Redis Caching Strategy
- **Use Cases**:
  - User sessions (JWT refresh tokens)
  - Frequently accessed data (user profiles, roles, permissions)
  - API response caching (expensive queries, external API calls)
  - Rate limiting counters
  - Distributed locks
- **Cache Keys Pattern**: `{module}:{entity}:{id}` (e.g., `user:profile:123`, `order:detail:456`)
- **TTL Strategy**:
  - Short-lived (5-15 min): Frequently changing data (user sessions)
  - Medium-lived (1-6 hours): Semi-static data (user profiles, roles)
  - Long-lived (24 hours): Rarely changing data (reference data, configurations)
  - No TTL: Truly static data (with manual invalidation)
- **Cache-Aside Pattern** (Lazy Loading):
  ```java
  1. Check cache
  2. If miss → Load from DB
  3. Store in cache
  4. Return data
  ```
- **Write-Through Pattern**: For critical data (write to DB and cache simultaneously)

### Cache Invalidation Rules
- **Time-Based**: TTL expiration (automatic)
- **Event-Based**: Invalidate on entity updates/deletes
  - Update: Invalidate specific key (`user:profile:123`)
  - Delete: Invalidate key and related keys (e.g., user's orders)
  - Bulk Update: Invalidate pattern (`user:profile:*`)
- **Manual Invalidation**: Admin endpoints for cache clearing (with authentication)
- **Cache Warming**: Pre-load critical data on application startup (optional)
- **Invalidation Strategy**:
  - **Immediate**: For user-facing data (user profile, orders)
  - **Lazy**: For background data (statistics, reports)
  - **Pattern-Based**: Invalidate all keys matching pattern (use `KEYS` or `SCAN` carefully)

### Local Caching vs Distributed Caching
- **Local Caching (Caffeine)**:
  - Use for: Application-level cache (in-memory, single instance)
  - Pros: Fast access, no network overhead
  - Cons: Not shared across instances, memory limited
  - Use cases: Frequently accessed constants, configuration, small datasets
- **Distributed Caching (Redis)**:
  - Use for: Shared cache across multiple instances
  - Pros: Shared state, scalable, persistent
  - Cons: Network latency, requires Redis infrastructure
  - Use cases: User sessions, shared data, rate limiting
- **Hybrid Approach**: 
  - L1 Cache (Local): Hot data, very frequent access
  - L2 Cache (Redis): Warm data, shared across instances
  - Fallback: Local → Redis → Database

### Cache Implementation Guidelines
- Use Spring Cache abstraction (`@Cacheable`, `@CacheEvict`, `@CachePut`)
- Configure cache manager: `RedisCacheManager` for distributed, `CaffeineCacheManager` for local
- Always handle cache failures gracefully (fallback to DB)
- Monitor cache hit/miss rates
- Set appropriate cache size limits (prevent OOM)
- Use cache versioning for schema changes (e.g., `user:profile:v2:123`)

## Performance Best Practices

### N+1 Query Detection & Prevention
- **Problem**: Fetching related entities in loops causes multiple queries
- **Detection**:
  - Enable Hibernate SQL logging: `spring.jpa.show-sql=true` (dev only)
  - Use `@Query` with `JOIN FETCH` for eager loading
  - Monitor query count in logs
- **Solutions**:
  - **Eager Fetching**: Use `@EntityGraph` or `JOIN FETCH` in queries
  - **Batch Fetching**: Configure `hibernate.jdbc.batch_size` and `@BatchSize`
  - **DTO Projection**: Select only needed fields (avoid loading full entities)
  - **Pagination**: Always paginate large result sets
- **Example**:
  ```java
  // Bad: N+1 queries
  List<OrderEntity> orders = orderRepository.findAll();
  orders.forEach(order -> order.getItems().size()); // N queries
  
  // Good: Single query with JOIN FETCH
  @Query("SELECT o FROM OrderEntity o JOIN FETCH o.items WHERE o.customer.id = :customerId")
  List<OrderEntity> findByCustomerWithItems(@Param("customerId") Long customerId);
  ```

### Batch Insert/Update
- **Batch Inserts**: Use `JpaRepository.saveAll()` with batch configuration
- **Configuration** (`application.yml`):
  ```yaml
  spring.jpa.properties.hibernate.jdbc.batch_size: 50
  spring.jpa.properties.hibernate.order_inserts: true
  spring.jpa.properties.hibernate.order_updates: true
  spring.jpa.properties.hibernate.jdbc.batch_versioned_data: true
  ```
- **Best Practices**:
  - Batch size: 20-50 (adjust based on entity size)
  - Use `@Transactional` for batch operations
  - Flush and clear session periodically for large batches
  - Consider bulk operations for massive updates (`@Modifying @Query`)

### Query Optimization
- **Indexes**: Add indexes on:
  - Foreign keys
  - Frequently queried columns (status, date ranges, customer_id)
  - Composite indexes for multi-column queries
- **Query Hints**: Use `@QueryHints` for query optimization
- **Avoid SELECT N+1**: Use `JOIN FETCH` or `@EntityGraph`
- **Pagination**: Always use `Pageable` for large datasets (default: 20 items)
- **Projection**: Use DTO projections instead of loading full entities
- **Query Tuning**:
  - Use `EXPLAIN` to analyze query plans
  - Avoid `SELECT *` (select only needed columns)
  - Use `LIMIT` in native queries
  - Avoid functions in WHERE clause (prevents index usage)

### Profiling Tools
- **Java Flight Recorder (JFR)**:
  - Enable in production: `-XX:+FlightRecorder -XX:StartFlightRecording`
  - Analyze: CPU usage, memory allocation, method profiling
  - Use for: Performance bottlenecks, memory leaks
- **Micrometer Metrics**:
  - Expose metrics: `/actuator/metrics`
  - Key metrics: HTTP request duration, database query time, cache hit/miss
  - Integration: Prometheus, Grafana
- **Spring Boot Actuator**:
  - Health checks: `/actuator/health`
  - Metrics: `/actuator/metrics`
  - Thread dump: `/actuator/threaddump`
  - Heap dump: `/actuator/heapdump` (production: secure endpoint)

### Connection Pool Tuning (HikariCP)
- **Configuration** (`application.yml`):
  ```yaml
  spring.datasource.hikari:
    maximum-pool-size: 20          # Max connections (adjust based on DB capacity)
    minimum-idle: 5                 # Min idle connections
    connection-timeout: 30000       # 30 seconds
    idle-timeout: 600000            # 10 minutes
    max-lifetime: 1800000           # 30 minutes
    leak-detection-threshold: 60000 # 60 seconds (detect connection leaks)
  ```
- **Best Practices**:
  - `maximum-pool-size`: Start with 10, increase based on load (max: DB max_connections / app instances)
  - `minimum-idle`: Keep some connections warm (faster response)
  - Monitor: Connection pool metrics via Actuator
  - Connection leaks: Enable `leak-detection-threshold` in dev/test
- **Monitoring**: Track active/idle connections, wait time, timeout errors

## Monitoring & Observability

### Prometheus Metrics
- **Integration**: Spring Boot Actuator + Micrometer Prometheus
- **Endpoint**: `/actuator/prometheus` (scraped by Prometheus)
- **Key Metrics to Expose**:
  - HTTP requests: `http_server_requests_seconds` (duration, status, endpoint)
  - Database queries: `jdbc_connections_active`, `jdbc_query_execution_seconds`
  - Cache: `cache_gets_total`, `cache_puts_total`, `cache_evictions_total`
  - JVM: `jvm_memory_used_bytes`, `jvm_gc_pause_seconds`, `jvm_threads_live`
  - Business metrics: Custom counters/gauges (orders created, payments processed)
- **Custom Metrics**: Use `MeterRegistry` to create business-specific metrics
- **Labels**: Add meaningful labels (endpoint, status, method) for filtering

### Grafana Dashboards
- **Dashboard Categories**:
  1. **Application Health**: Request rate, error rate, response time (p50, p95, p99)
  2. **Database**: Query performance, connection pool, slow queries
  3. **JVM**: Memory usage, GC pauses, thread count
  4. **Cache**: Hit/miss ratio, eviction rate, size
  5. **Business Metrics**: Orders, payments, users (custom dashboards)
- **Alerting Rules**: Configure in Grafana or Prometheus Alertmanager
- **Refresh Rate**: 30 seconds (real-time monitoring)

### Log Aggregation (ELK/OpenSearch)
- **Stack**: Elasticsearch/OpenSearch + Logstash/Fluentd + Kibana
- **Log Shipping**: 
  - Application logs → Filebeat → Elasticsearch
  - Or: Direct to OpenSearch via REST API
- **Log Structure**:
  - JSON format (structured logging)
  - Include: timestamp, level, traceId, service, message, context
  - Example: `{"timestamp":"2024-01-01T10:00:00Z","level":"INFO","traceId":"abc123","service":"tailor-shop","message":"Order created","orderId":123}`
- **Indexing Strategy**:
  - Daily indices: `logs-tailor-shop-2024-01-01`
  - Retention: 30 days (production), 7 days (dev)
  - Index templates for consistent mapping
- **Search & Analysis**: Use Kibana for log search, filtering, visualization

### Alerting Rules
- **Critical Alerts** (P0 - Immediate):
  - Application down (health check fails)
  - Error rate > 5% for 5 minutes
  - Database connection pool exhausted
  - Memory usage > 90%
- **Warning Alerts** (P1 - Within 1 hour):
  - Response time p95 > 2 seconds
  - Cache hit rate < 70%
  - Disk usage > 80%
  - Failed deployment
- **Info Alerts** (P2 - Daily summary):
  - High request volume (unusual spike)
  - Slow query detected (> 1 second)
- **Alert Channels**: Email, Slack, PagerDuty (for P0)
- **Alert Rules**: Define in Prometheus Alertmanager or Grafana

### Distributed Tracing
- **Tool**: OpenTelemetry or Zipkin (optional, for microservices)
- **Trace Context**: Propagate `traceId` in HTTP headers
- **Span Tags**: Add business context (userId, orderId) to spans

## Deployment Architecture

### Cloud Architecture (AWS)
- **VPC (Virtual Private Cloud)**:
  - Public subnets: Application Load Balancer (ALB)
  - Private subnets: Application servers (EC2/ECS/EKS)
  - Database subnets: RDS MySQL (isolated, no internet access)
  - NAT Gateway: For outbound internet access from private subnets
- **Application Load Balancer (ALB)**:
  - Health checks: `/actuator/health` (every 30 seconds)
  - SSL/TLS termination: ACM certificates
  - Routing: Path-based or host-based (if multiple services)
  - Target groups: EC2 instances or ECS tasks
- **Auto Scaling Group (ASG)**:
  - Min instances: 2 (high availability)
  - Max instances: 10 (scale based on load)
  - Scaling policies:
    - CPU utilization > 70%: Scale out
    - CPU utilization < 30%: Scale in
    - Request count: Scale based on ALB request count
  - Health check: ELB health check (replace unhealthy instances)

### S3 + CloudFront Caching
- **S3 Buckets**:
  - `tailor-shop-uploads`: User-uploaded files (private, signed URLs)
  - `tailor-shop-static`: Static assets (public, CloudFront origin)
- **CloudFront Distribution**:
  - Origin: S3 bucket for static assets
  - Caching:
    - Static assets (images, CSS, JS): TTL 1 year (with versioning)
    - API responses: TTL 0 (no cache, or short TTL with cache headers)
  - Behaviors:
    - `/static/*`: Cache for 1 year
    - `/api/*`: No cache (or 5 minutes with `Cache-Control` headers)
  - Invalidation: Automatic on deployment (via CI/CD) or manual
- **CDN Best Practices**:
  - Use versioned filenames for static assets (`app-v1.2.3.js`)
  - Set appropriate `Cache-Control` headers
  - Enable compression (gzip/brotli)

### Scaling Patterns
- **Horizontal Scaling**:
  - Stateless application: Scale out by adding instances
  - Load balancer distributes traffic
  - Session management: Use Redis (not sticky sessions)
- **Vertical Scaling**:
  - Increase instance size (CPU, memory) for compute-intensive tasks
  - Use for: Database, cache servers
- **Auto-Scaling Triggers**:
  - CPU-based: Scale when CPU > 70%
  - Memory-based: Scale when memory > 80%
  - Request-based: Scale when request rate > threshold
  - Custom metrics: Scale based on queue depth, error rate
- **Scaling Strategy**:
  - **Predictive**: Scale before peak hours (scheduled scaling)
  - **Reactive**: Scale based on current metrics (auto-scaling)
  - **Cost Optimization**: Scale down during off-peak hours

### Infrastructure as Code (IaC)
- **Tool**: Terraform or AWS CDK
- **Resources to Define**:
  - VPC, subnets, security groups
  - ALB, target groups, auto-scaling groups
  - RDS instances, ElastiCache (Redis)
  - S3 buckets, CloudFront distributions
  - IAM roles and policies
- **Benefits**: Version control, reproducibility, disaster recovery

### Disaster Recovery & Backup
- **Database Backups**:
  - Automated daily backups (RDS automated backups)
  - Retention: 30 days
  - Cross-region replication (optional, for critical data)
- **Application Backups**:
  - Configuration files in version control
  - Docker images in ECR (Elastic Container Registry)
- **Recovery Time Objective (RTO)**: < 1 hour
- **Recovery Point Objective (RPO)**: < 15 minutes (last backup)

